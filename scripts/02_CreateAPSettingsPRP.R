rm(list=ls())

#Name:     013_CreateAPSettingsPRP.R
#Purpose:  Create a PRP file such that I can load it into the AP GUI and save 
#             time and prevent mistakes
#Author:   PA Fekety, Colorado State University, patrick.fekety@colostate.edu
#Date:     2021.01.05

#Notes:
# The PRP is a text file that holds settings for AreaProcessor.exe. 
# Using paste0() instead of file.path() because other programs weren't reading
#   file paths correctly

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# Load Libraries
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------

library(rgdal)

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# Assign Variables
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------

#Spatial reference system of lidar data (e.g., EPSG 5070)
SRS.Lidar = CRS("+init=epsg:5070")

#File path to Fusion Executuables
dirFUSION <- "C:\\FUSION\\"

#Lidar Project Name
project <- "CO_ARRA_ParkCo_2010"

#Raster resolution
CELLSIZE <- 30

#Maximum number of processing cores
NCORESMAX <- 26

#Working directory (same as dirWD in script 01_PrepareDataForFusion.py)
DIR_BASE <- paste0("D:\\LidarProcessing\\")

#Direcotry of lidar data
DIR_LAZ5070 <- paste0(DIR_BASE, project, "\\", "Points\\", "LAZ5070\\")

#Directory of AP scripts
DIRSCRIPTS <- "C:\\Users\\pafekety\\Desktop\\CMS2LidarProcessing\\scripts\\AP" # Do not include the trailing \\


# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
#Functions
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------

#Purpose:
#	Calculates the mid latitude of the study area. This is an input into FUSION's setup.bat
#	and is used to calculate solar radiation index (SRI).
#Inputs:
#	xMid - (num) the midpoint, in the y-direction, of the study area in AEA coordinates.
#	yMid - (num) the midpoint, in the y-direction, of the study area in AEA coordinates.
#Output:
#	the Latitude, in degrees, of the study area's midpoint
calculateLatitude <- function(xMid,yMid) {
	#determine if inputs are specified
	if (is.null(xMid)) stop("x-coordinate not specified")
	if (is.null(yMid)) stop("y-coordinate not specified")
	
	#create a spatial object for the midpoint
	midPoint.LandTrendr <- SpatialPoints(coords=cbind(xMid,yMid), proj4string=SRS.Lidar)
	#transform midpoint spatial object to lat long
	midPoint.LatLon <- spTransform(midPoint.LandTrendr, CRS("+proj=longlat +ellps=GRS80 +datum=NAD83 +no_defs "))
	
	#return latitude value
	return(round(midPoint.LatLon@coords[2],2))
}


#Purpose:
#	Runs FUSION's DTM describe
#Input:
#	DTMSPEC (str) - file paths to DTM
#	OutputDirectory (str) - Processing Home
#	OutputName (str) - Name of the files generated
#	ALL (logical) - Should all the DTMS be described?
#	WHICH (vector) - which DTMs should be included
#Output:
#	CSV file generated by
RunDtmDescribe <- function(DtmDirectory, OutputDirectory, OutputName, ALL=TRUE, WHICH=NULL, dirFUSION){
	
	if(ALL){
	#find the DTMs in DtmSpec
		DtmPaths <- dir(path=DtmDirectory, full.names=TRUE, pattern="[.]dtm$")
	} else {
		DtmPaths <- vector()
		for(i in 1:length(WHICH)){
			DtmPath <- dir(path=DtmDirectory, full.names=TRUE, pattern=paste0(WHICH[i],".dtm$"))
			DtmPaths <- c(DtmPaths, DtmPath)
		}
	}
	
	#write a text file of the DTM file paths
	DtmFileTxt <- paste0(OutputDirectory, OutputName, "_filelist.txt")
	sink(file=DtmFileTxt)
	for (DtmPath in DtmPaths){
		cat(DtmPath)
		cat('\n')
	}
	sink()
	
	#Run Fusion DTMDescribe
	shell(
		paste0(dirFUSION, "DTMDescribe.exe ", DtmFileTxt, " ", OutputDirectory, OutputName, "_Summary.csv")
		)
}

#Name:
#	writeSection1
#Purpose:
#	Writes section 1 of the PRP; Header
#Inputs:
#	NONE
#Outputs:
#	Text for section 1
writeSection1 <- function(){
	#Section 1
	cat('[Header]')
	cat('\n')
	cat('Program=AreaProcessor')
	cat('\n')
	cat('Version=1.88000000') #Okay, I couldn't find a way to calculate / look up version number so I hard coded it in
	cat('\n')
}


#Name:
#	writeSection2
#Purpose:
#	Write section 2 of the PRP; AreaSpecificOptions
#Inputs:
#	PROJECT (char) - name of the lidar project
#	LATITUDE (int) - latitude for center of the lidar unit; default is 45 degrees
#		
#Outputs:
#	Text for section 2
writeSection2 <- function(PROJECT = "", LATITUDE = 45){
	#Section 2
	cat('[AreaSpecificOptions]')
	cat('\n')
	cat(paste0('AreaName=', PROJECT))
	cat('\n')
	cat('CoordinateSystem=0') 
	cat('\n')
	cat('CoordinateSystemZone=0') #Other
	cat('\n')
	cat('MeasurementUnits=0')
	cat('\n')
	cat(paste0('Latitude=', LATITUDE))
	cat('\n')
	cat('MinimumIntensity=-1')
	cat('\n')
	cat('MaximumIntensity=254')
	cat('\n')
	cat('ClassOptionString=0,1,2,3,4,5')
	cat('\n')
}


#Name:
#	writeSection3
#Purpose:
#	Write section 3 of the PRP; ProcessingOptions
#Inputs:
#	TILEHEIGHT (int) - tile height in meters; needs to be divisible by cell size
#	TILEWIDTH (int) - tile with in meters; needs to be divisible by cell size
#	CELLSIZE (num) - Cell size for output rasters
#Outputs:
#	Text for section 3
writeSection3 <- function(TILEHEIGHT, TILEWIDTH, CELLSIZE, NCORESMAX){
	
	#Buffer, 2 times the Cell Size
	BUFFER <- 2*CELLSIZE
	 
	#Section 3
	cat('[ProcessingOptions]')
	cat('\n')
	cat(paste0('AlignmentCellSize=', CELLSIZE, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat('Use64bitTools=1')
	cat('\n')
	cat('ForceAlignmentToGrid=1')
	cat('\n')
	cat('TileBaseName=')
	cat('\n')
	cat('TileComputeMethod=4') #This value is 1 smaller than the GUI display
	cat('\n')
	cat('UseCustomLog=1')
	cat('\n')
	cat('UseIndividualTileLogs=1')
	cat('\n')
	cat('OmitDriveLetter=0')
	cat('\n')
	cat('DeleteTiles=1')
	cat('\n')
	cat('ClipNewTiles=1')
	cat('\n')
	cat('UseFileCaching=0')
	cat('\n')
	cat('CreateIndexFiles=0')
	cat('\n')
	cat('CheckForClippedTiles=1')
	cat('\n')
	cat('UseMultipleProcesses=1')
	cat('\n')
	cat('MonitorBatchFilesSeparately=0')
	cat('\n')
	cat(paste0('TileWidth=', TILEWIDTH, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('TileHeight=', TILEHEIGHT, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('BufferWidth=', BUFFER, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat('MaxReturnsperTile=70000000')
	cat('\n')
	cat(paste0('NumberOfProcessingStreams=', NCORESMAX)) #How many Cores?
	cat('\n')
}


#Name:
#	writeSection4
#Purpose:
#	Write section 4 of the PRP; BlockOptions
#Inputs:
#	BLOCKWIDTH - (int) Processing block width. A dedicated stream runs a block
#	BLOCKHEIGHT - (int) Processing block height. A dedicated stream runs a block
#Outputs:
#	Text for section 4
writeSection4 <- function(BLOCKWIDTH, BLOCKHEIGHT){

	#Not Sure what this is doing
	BLOCKADJUSTEDUSERWIDTH <- BLOCKWIDTH

	cat('[BlockOptions]')
	cat('\n')
	cat('BlockMethod=1') #0, use a single block; 1 - use width and height; 2 - use columns and rows
	cat('\n')
	cat(paste0('BlockUserWidth=', BLOCKWIDTH, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('BlockUserHeight=', BLOCKHEIGHT, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat(paste0('BlockAdjustedUserWidth=', BLOCKADJUSTEDUSERWIDTH, '.00000000')) #Not sure if all the decimal places are required
	cat('\n')
	cat('BlockUserColumns=5')
	cat('\n')
	cat('BlockUserRows=5')
	cat('\n')
	cat('BlockAlignToBlockSize=1') #0 - False; 1 - True
	cat('\n')
}


#Name:
#	writeSection5
#Purpose:
#	Write section 5 of the PRP; Scripts
#Inputs:
#	HOMEFOLDER (char) - Base directory for the AP processing
#	PROCESSINGHOME (char) - Directory holding processing scripts
#Outputs:
#	Text for section 5
writeSection5 <- function(HOMEFOLDER, PROCESSINGHOME, DIRSCRIPTS){


	#Primary Batch File Name
	PRIMARY <- "APFusion"

	cat('[Scripts]')
	cat('\n')
	cat(paste0('WorkingDirName=', HOMEFOLDER, 'Products'))
	cat('\n')
	cat(paste0('PrimaryBatchFileName=', PROCESSINGHOME, PRIMARY, '.bat'))
	cat('\n')
	cat(paste0('ProcessingDirName=', DIRSCRIPTS))
	cat('\n')
	cat(paste0('StreamPreprocessBatchFileName=', DIRSCRIPTS, '\\', 'preblock.bat'))
	cat('\n')
	cat(paste0('PreprocessBatchFileName=', DIRSCRIPTS, '\\', 'Basic_setup.bat'))
	cat('\n')
	cat(paste0('ProcessingBatchFileName=', DIRSCRIPTS, '\\', 'tile.bat'))
	cat('\n')
	cat(paste0('CleanupBatchFileName=', DIRSCRIPTS, '\\', 'posttile.bat'))
	cat('\n')
	cat(paste0('StreamCleanupBatchFileName=', DIRSCRIPTS, '\\', 'postblock.bat'))
	cat('\n')
	cat(paste0('ProjectionDirName=', DIRSCRIPTS, '\\', 'epsg5070.prj'))
	cat('\n')
	cat('CacheDirName=')
	cat('\n')
}


#Name:
#	writeSection6
#Purpose:
#	Write section 6 of the PRP
#Inputs:
#	DIR_LIDAR (str) - a file path to the lidar files
#Outputs:
#	Text for section 6
writeSection6 <- function(DIR_LIDAR, ext = ""){
	
	#file path for lidar files
	ext = toupper(ext)
	if(!is.element(ext, c("LAS", "LAZ"))) stop ("ext must be LAS or LAZ")
	if(ext == "LAS"){
		LAS_FILES <- dir(DIR_LIDAR, pattern = "[.]las$", full.names = TRUE, ignore.case = TRUE)
	}
	if(ext == "LAZ"){
		LAS_FILES <- dir(DIR_LIDAR, pattern = "[.]laz$", full.names = TRUE, ignore.case = TRUE)
	}
	
	#Need to keep track of the minimum and maximum x and y-values for writeSection11()
	xMinPoints <- vector()
	xMaxPoints <- vector()
	yMinPoints <- vector()
	yMaxPoints <- vector()
	
	cat('[PointData]')
	cat('\n')
	cat(paste0('ObjectCount=', length(LAS_FILES)))
	cat('\n')
	for(i in 1:length(LAS_FILES)){
		#the key to reading a header. this is from the APRS website
		hd <- publicHeaderDescription()
		#creates a blank header
		pheader <- vector("list", nrow(hd))
		#assigns names to the list
		names(pheader) <- hd$Item
		#Opens a connection to the LAS file
		con <- file(LAS_FILES[i], open = "rb")
		#check to see if the file is a lasfile
		isLASFbytes <- readBin(con, "raw", size = 1, n = 4, endian = "little")
			pheader[[hd$Item[1]]] <- readBin(isLASFbytes, "character", size = 4, endian = "little")
		if (!pheader[[hd$Item[1]]] == "LASF") {
			stop("The LASfile input is not a valid LAS file")
		}
		for (j in 2:nrow(hd)) {
			pheader[[hd$Item[j]]] <- readBin(con, what = hd$what[j], 
				size = hd$Rsize[j], endian = "little", n = hd$n[j])
		}
		#close the connection
		close(con)

		#look up min, max, and number of points		
		xMin <- pheader$'Min X'
		xMax <- pheader$'Max X'
		yMin <- pheader$'Min Y'
		yMax <- pheader$'Max Y'
		zMin <- pheader$'Min Z'
		zMax <- pheader$'Max Z'
		nPoints <- pheader$'Number of point records'
		
		#update min and max x and y values
		xMinPoints <- c(xMinPoints, xMin)
		xMaxPoints <- c(xMaxPoints, xMax)
		yMinPoints <- c(yMinPoints, yMin)
		yMaxPoints <- c(yMaxPoints, yMax)
		
		#Build the string
		cat(paste0('Object_', i, '=1,1,', xMin, ',', yMin, ',', zMin, ',', xMax, ',', yMax, ',', zMax, ',' , nPoints, ',' , LAS_FILES[i]))
		cat('\n')
	}
}

#Name:
#	getLidarExtent
#Purpose:
#	Retrieve the extent of the lidar collection
#Inputs:
#	DIR_LIDAR (str) - a file path to the lidar files
#Outputs:
#	A list tracking the min and max coordinates of the lidar returns; note these values are extracted from the header
getLidarExtent <- function(DIR_LIDAR, ext = ""){
	
	#file path for lidar files
	ext = toupper(ext)
	if(!is.element(ext, c("LAS", "LAZ"))) stop ("ext must be LAS or LAZ")
	if(ext == "LAS"){
		LAS_FILES <- dir(DIR_LIDAR, pattern = "[.]las$", full.names = TRUE, ignore.case = TRUE)
	}
	if(ext == "LAZ"){
		LAS_FILES <- dir(DIR_LIDAR, pattern = "[.]laz$", full.names = TRUE, ignore.case = TRUE)
	}
	
	#Need to keep track of the minimum and maximum x and y-values for writeSection11()
	xMinPoints <- vector()
	xMaxPoints <- vector()
	yMinPoints <- vector()
	yMaxPoints <- vector()
	
	for(i in 1:length(LAS_FILES)){
		#the key to reading a header. this is from the APRS website
		hd <- publicHeaderDescription()
		#creates a blank header
		pheader <- vector("list", nrow(hd))
		#assigns names to the list
		names(pheader) <- hd$Item
		#Opens a connection to the LAS file
		con <- file(LAS_FILES[i], open = "rb")
		#check to see if the file is a lasfile
		isLASFbytes <- readBin(con, "raw", size = 1, n = 4, endian = "little")
			pheader[[hd$Item[1]]] <- readBin(isLASFbytes, "character", size = 4, endian = "little")
		if (!pheader[[hd$Item[1]]] == "LASF") {
			stop("The LASfile input is not a valid LAS file")
		}
		for (j in 2:nrow(hd)) {
			pheader[[hd$Item[j]]] <- readBin(con, what = hd$what[j], 
				size = hd$Rsize[j], endian = "little", n = hd$n[j])
		}
		#close the connection
		close(con)

		#look up min, max, and number of points		
		xMin <- pheader$'Min X'
		xMax <- pheader$'Max X'
		yMin <- pheader$'Min Y'
		yMax <- pheader$'Max Y'
		zMin <- pheader$'Min Z'
		zMax <- pheader$'Max Z'
		nPoints <- pheader$'Number of point records'
		
		#update min and max x and y values
		xMinPoints <- c(xMinPoints, xMin)
		xMaxPoints <- c(xMaxPoints, xMax)
		yMinPoints <- c(yMinPoints, yMin)
		yMaxPoints <- c(yMaxPoints, yMax)
		
	}
	#Return the min and max x and y's
	return(list(
		xMinPoints = min(xMinPoints), 
		xMaxPoints = max(xMaxPoints),
		yMinPoints = min(yMinPoints),
		yMaxPoints = max(yMaxPoints))
	)
}


#Name:
#	writeSection7
#Purpose:
#	Write section 7 of the PRP; GroundData
#Inputs:
#	PROCESSINGHOME (str) - file path 
#Outputs:
#	Text for section 7
writeSection7 <- function(DTMSPEC ,PROCESSINGHOME, dirFUSION){
	#Run DTMDescribe.exe
	RunDtmDescribe(DtmDirectory = DTMSPEC, OutputDirectory = PROCESSINGHOME, OutputName = "DTM_Ground", dirFUSION = dirFUSION)
	
	#Read in the CSV created with RunDtmDescribe()
	DtmDescribe <- read.csv(file=paste0(PROCESSINGHOME, "DTM_Ground_Summary.csv" ), as.is=TRUE)
	
	#Number of ground DTMs
	OBJECTCOUNT <- nrow(DtmDescribe)
	
	cat('[GroundData]')
	cat('\n')
	cat(paste0('ObjectCount=', OBJECTCOUNT))
	cat('\n')
	
	for(i in 1:OBJECTCOUNT){
		ORIGIN_X <- DtmDescribe[i,"Origin.X"]
		ORIGIN_Y <- DtmDescribe[i,"Origin.Y"]
		MIN_VAL <- DtmDescribe[i,"Min.data.value"]
		UPPER_RIGHT_X <- DtmDescribe[i,"Upper.right.X"]
		UPPER_RIGHT_Y <- DtmDescribe[i,"Upper.right.Y"]
		MAX_VAL <- DtmDescribe[i,"Max.data.value"]
		PATH  <- DtmDescribe[i,"File.name"]
	
		cat(paste0("Object_", i, "=1,1,", ORIGIN_X, "," , ORIGIN_Y, ",", MIN_VAL, ",", UPPER_RIGHT_X, ",", UPPER_RIGHT_Y, ",", MAX_VAL, ",1,", PATH))
		cat('\n')
	}	
}


#Name:
#	writeSection8
#Purpose:
#	Write section8  of the PRP; DensityData
#Inputs:
#	PRODUCTHOME (str) - file path
#	PROCESSINGHOME (str) - file path
#	
#Outputs:
#	Text for section 8
writeSection8 <- function(PRODUCTHOME, PROCESSINGHOME, dirFUSION){
	#Run DtmDescribe on the density DTM
	RunDtmDescribe(DtmDirectory=paste0(PRODUCTHOME, "QAQC\\"), OutputDirectory=PROCESSINGHOME, OutputName="DTM_Density", ALL=FALSE, WHICH="QAQC_return_count", dirFUSION = dirFUSION)
	#Read in the CSV created with RunDtmDescribe()
	DtmDescribe <- read.csv(file=paste0(PROCESSINGHOME, "DTM_Density_Summary.csv" ), as.is=TRUE)
	
	#Number of density DTMs
	OBJECTCOUNT <- nrow(DtmDescribe)

	cat('[DensityData]')
	cat('\n')
	cat('ObjectCount=1')
	cat('\n')

	for( i in 1:OBJECTCOUNT){
		ORIGIN_X <- DtmDescribe[i,"Origin.X"]
		ORIGIN_Y <- DtmDescribe[i,"Origin.Y"]
		MIN_VAL <- DtmDescribe[i,"Min.data.value"]
		UPPER_RIGHT_X <- DtmDescribe[i,"Upper.right.X"]
		UPPER_RIGHT_Y <- DtmDescribe[i,"Upper.right.Y"]
		MAX_VAL <- DtmDescribe[i,"Max.data.value"]
		PATH  <- DtmDescribe[i,"File.name"]
	
		cat(paste0("Object_", i, "=1,1,", ORIGIN_X, "," , ORIGIN_Y, ",", MIN_VAL, ",", UPPER_RIGHT_X, ",", UPPER_RIGHT_Y, ",", MAX_VAL, ",1,", PATH))
		cat('\n')
	}
}


#Name:
#	writeSection9
#Purpose:
#	Write section 9 of the PRP; MaskLayers
#Inputs:
#	NONE
#Outputs:
#	Text for section 9
writeSection9 <- function(){
	cat('[MaskLayers]')
	cat('\n')
	cat('ObjectCount=0')
	cat('\n')
}


#Name:
#	writeSection10
#Purpose:
#	Write section 10 of the PRP; ProcessingBlocks
#Inputs:
#	NBLOCKSHIGH (int) - 
#	NBLOCKSWIDE (int) - 
#	BLOCKHEIGHT (int) - 
#	BLOCKWIDTH (int) - 
#	CELLSIZE (num) - Cell size for output rasters
#	DTMDESCRIBE
#	
#Outputs:
#	Text for section 10
writeSection10 <- function(NBLOCKSHIGH, NBLOCKSWIDE, BLOCKHEIGHT, BLOCKWIDTH, CELLSIZE,  LIDAREXENT){
	#Number of blocks
	nBlocks <- NBLOCKSHIGH * NBLOCKSWIDE

	xMin <- LIDAREXENT$xMinPoints
	xMax <- LIDAREXENT$xMaxPoints
	yMin <- LIDAREXENT$yMinPoints
	yMax <- LIDAREXENT$xMaxPoints
	
	#Shift cell origin to match LandTrendr
	xMin <- xMin - xMin%%CELLSIZE - CELLSIZE
	yMin <- yMin - yMin%%CELLSIZE - CELLSIZE

	cat('[ProcessingBlocks]')
	cat('\n')
	cat(paste0('ObjectCount=', nBlocks))
	cat('\n')

	i <- 1
	xMinBlock <- xMin
	xMaxBlock <- xMin + BLOCKWIDTH

	for(blockInX in 1:NBLOCKSWIDE){
		yMinBlock <- yMin
		yMaxBlock <- yMin + BLOCKHEIGHT
		for( blockInY in 1:NBLOCKSHIGH){
			OBJECT <- paste0("Object_", i)

			BLOCKID <- i
			BLOCKNAME <- paste0("BLOCK",i)
			cat(paste0(OBJECT, "=1,", xMinBlock, "," , yMinBlock, ",", xMaxBlock, ",", yMaxBlock, ",", BLOCKID, ",", BLOCKNAME))
			cat('\n')

			yMinBlock <- yMinBlock + BLOCKHEIGHT
			yMaxBlock <- yMaxBlock + BLOCKHEIGHT

			i <- i + 1
		}
		xMinBlock <- xMinBlock + BLOCKWIDTH
		xMaxBlock <- xMaxBlock + BLOCKWIDTH
	}
}



#Name:
#	writeSection11
#Purpose:
#	Write section 11 of the PRP; ProcessingExtent
#Inputs:
#	DTMDESCRIBE
#	LIDARPOINTS
#	CELLSIZE (num) - Cell size for output rasters
#Outputs:
#	Text for section 11
writeSection11 <- function(LIDAREXTENT, CELLSIZE){
	#Lidar Return min and max (from writeSection6())
	xMinPoints <- LIDAREXTENT$xMinPoints
	xMaxPoints <- LIDAREXTENT$xMaxPoints
	yMinPoints <- LIDAREXTENT$yMinPoints
	yMaxPoints <- LIDAREXTENT$yMaxPoints
	
	
	xMinUser <- xMinPoints - xMinPoints %% CELLSIZE - CELLSIZE
	xMaxUser <- xMaxPoints - xMaxPoints %% CELLSIZE + CELLSIZE
	yMinUser <- yMinPoints - yMinPoints %% CELLSIZE - CELLSIZE
	yMaxUser <- yMaxPoints - yMaxPoints %% CELLSIZE + CELLSIZE


	cat('[ProcessingExtent]')
	cat('\n')
	cat('HaveUserExtent=1')
	cat('\n')
	cat(paste0('UserMinX=', xMinUser))
	cat('\n')
	cat(paste0('UserMinY=', yMinUser))
	cat('\n')
	cat(paste0('UserMaxX=', xMaxUser))
	cat('\n')
	cat(paste0('UserMaxY=', yMaxUser))
	cat('\n')
	cat(paste0('OverallMinX=', xMinPoints))
	cat('\n')
	cat(paste0('OverallMinY=', yMinPoints))
	cat('\n')
	cat(paste0('OverallMaxX=', xMaxPoints))
	cat('\n')
	cat(paste0('OverallMaxY=', yMaxPoints))
	cat('\n')
	cat(paste0('AdjustedOverallMinX=', xMinUser))
	cat('\n')
	cat(paste0('AdjustedOverallMinY=', yMinUser))
	cat('\n')
	cat(paste0('AdjustedOverallMaxX=', xMaxUser))
	cat('\n')
	cat(paste0('AdjustedOverallMaxY=', yMaxUser))
	cat('\n')
	cat(paste0('AdjustedUserMinX=', xMinUser))
	cat('\n')
	cat(paste0('AdjustedUserMinY=', yMinUser))
	cat('\n')
	cat(paste0('AdjustedUserMaxX=', xMaxUser))
	cat('\n')
	cat(paste0('AdjustedUserMaxY=', yMaxUser))
	cat('\n')
}


#Name:
#	publicHeaderDescription 
#Purpose:
#	creates a header description for LAS files.
#	I found the code here:https://github.com/themel
#		Thomas Themel github@themel.com
#Inputs:
#	NULL
#Outputs:
#	a list that will store pblic header info for a LAS file.
publicHeaderDescription <- function() {
  hd <- structure(list(Item = c("File Signature (\"LASF\")",
                                "(1.1) File Source ID", "(1.1) Global Encoding",
                                "(1.1) Project ID - GUID data 1", "(1.1) Project ID - GUID data 2",
                                "(1.1) Project ID - GUID data 3", "(1.1) Project ID - GUID data 4",
                                "Version Major", "Version Minor", "(1.1) System Identifier",
                                "Generating Software", "(1.1) File Creation Day of Year",
                                "(1.1) File Creation Year", "Header Size", "Offset to point data",
                                "Number of variable length records",
                                "Point Data Format ID (0-99 for spec)", "Point Data Record Length",
                                "Number of point records", "Number of points by return",
                                "X scale factor", "Y scale factor", "Z scale factor", "X offset",
                                "Y offset", "Z offset", "Max X", "Min X", "Max Y", "Min Y", "Max Z",
                                "Min Z"), 
							Format = c("char[4]", "unsigned short", "unsigned short",
                                       "unsigned long", "unsigned short", "unsigned short",
                                       "unsigned char[8]", "unsigned char", "unsigned char", "char[32]",
                                       "char[32]", "unsigned short", "unsigned short", "unsigned short",
                                       "unsigned long", "unsigned long", "unsigned char", "unsigned short",
                                       "unsigned long", "unsigned long[5]", "double", "double", "double",
                                       "double", "double", "double", "double", "double", "double", "double",
                                       "double", "double"), 
							Size = c("4 bytes", "2 bytes", "2 bytes",
                                     "4 bytes", "2 byte", "2 byte", "8 bytes", "1 byte", "1 byte",
                                     "32 bytes", "32 bytes", "2 bytes", "2 bytes", "2 bytes", "4 bytes",
                                     "4 bytes", "1 byte", "2 bytes", "4 bytes", "20 bytes", "8 bytes",
                                     "8 bytes", "8 bytes", "8 bytes", "8 bytes", "8 bytes", "8 bytes",
                                     "8 bytes", "8 bytes", "8 bytes", "8 bytes", "8 bytes"), 
							Required = c("*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*",
                                         "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*",
                                         "*", "*", "*", "*", "*")), 
							.Names = c("Item", "Format", "Size", "Required"), 
							row.names = 2:33, 
							class = "data.frame")
  hd$what <- ""
  hd$what[grep("unsigned", hd$Format)] <- "integer"
  hd$what[grep("char", hd$Format)] <- "raw"	#this isn't quite right
  hd$what[grep("short", hd$Format)] <- "integer"
  hd$what[grep("long", hd$Format)] <- "integer"
  hd$what[grep("double", hd$Format)] <- "numeric"
  hd$signed <- TRUE
  hd$signed[grep("unsigned", hd$Format)] <- FALSE
  ## number of values in record
  hd$n <- as.numeric(gsub("[[:alpha:][:punct:]]", "", hd$Format))
  hd$n[hd$what == "character"] <- 1
  hd$n[is.na(hd$n)] <- 1
  ## size of record
  hd$Hsize <- as.numeric(gsub("[[:alpha:]]", "", hd$Size))
  ## size of each value in record
  hd$Rsize <- hd$Hsize / hd$n
  hd$Rsize[hd$what == "raw"] <- 1
  hd$n[hd$what == "raw"] <- hd$Hsize[hd$what == "raw"]
  hd
}


#Name:
#	writePRP
#Purpose:
#	Writes the PRP FUSION AP setup file
#Inputs:
#	NULL
#Outputs:
#	a list that will store pblic header info for a LAS file.
writePRP <- function(PROJECT, LATITUDE, HOMEFOLDER, PROCESSINGHOME, DIRSCRIPTS,
				PRODUCTHOME, DIR_LIDAR, tileWidth, tileHeight, blockWidth, blockHeight, 
				nBlocksHigh, nBlocksWide, nCores, DTMSPEC, dirFUSION, lidarExtent){
	#PRP file that will be written
	DIR_PRP = paste0(HOMEFOLDER, "PRP\\")
	if(!dir.exists(DIR_PRP)) dir.create(DIR_PRP)
	sink(paste0(DIR_PRP, PROJECT, "_APSetup.prp"))

	#header
	writeSection1()
	
	#Area Specific Options
	writeSection2(PROJECT = PROJECT, LATITUDE = LATITUDE)
	
	#Processing options
	writeSection3(TILEHEIGHT = tileHeight, TILEWIDTH = tileWidth, CELLSIZE = CELLSIZE, NCORESMAX = nCores)
	
	#Block Options
	writeSection4(BLOCKWIDTH = blockWidth, BLOCKHEIGHT = blockHeight)
	
	#Scripts
	writeSection5(HOMEFOLDER = HOMEFOLDER, PROCESSINGHOME = PROCESSINGHOME, DIRSCRIPTS = DIRSCRIPTS)
	
	#Point data
	writeSection6(DIR_LIDAR = DIR_LIDAR, ext = "LAZ")
	
	#Ground data
	if(length(dir(DTMSPEC)) > 0){
		writeSection7(DTMSPEC = DTMSPEC, PROCESSINGHOME = PROCESSINGHOME, dirFUSION = dirFUSION)
	}

	#Density data
	writeSection8(PRODUCTHOME = PRODUCTHOME, PROCESSINGHOME = PROCESSINGHOME, dirFUSION = dirFUSION)
	
	#Mask Layers
	writeSection9()
		
	#Processing Blocks
	writeSection10(NBLOCKSHIGH = nBlocksHigh, NBLOCKSWIDE = nBlocksWide, BLOCKHEIGHT = blockHeight, BLOCKWIDTH = blockWidth, CELLSIZE = CELLSIZE,  LIDAREXENT = lidarExtent)
	
	#Processing Extent
	writeSection11(LIDAREXTENT = lidarExtent, CELLSIZE = CELLSIZE)
	
	#Close diversion
	sink()
}


#Name:
#	createPRP 
#Purpose:
#	Creates the PRP FUSION AP setup file
#	This is the main function
#Inputs:
#	project
#	cellSize (num)
#	nCores (int)
#Outputs:
#	The PRP file for the AP setup file
createPRP <- function(project, cellSize, nCores, DIR_BASE, DIRSCRIPTS, DIR_LIDAR, dirFUSION){
	
	print(paste0("Creating ground DTM for ", project));flush.console()	
	
	#These folders are following the LTK naming scheme from setup.bat
	HOMEFOLDER <- paste0(DIR_BASE, project, '\\')
	PROCESSINGHOME <- paste0(HOMEFOLDER, 'Processing\\AP\\')
	DTMSPEC <- paste0(HOMEFOLDER, 'Deliverables\\DTM\\')
	PRODUCTHOME <- paste0(HOMEFOLDER, "Products\\")

	lidarExtent <- getLidarExtent(DIR_LIDAR, ext = "LAZ")
	#- Find Latitude Lidar Points
	xMid <- mean(lidarExtent$xMinPoints, lidarExtent$xMaxPoints)
	yMid <- mean(lidarExtent$yMinPoints, lidarExtent$yMaxPoints)
	
	latitude <- calculateLatitude(xMid = xMid, yMid = yMid)

	##------------
	# Find optimal (?) block sizes
	##------------
	#Note: I struggled on this one a little. It is a tough balance between using all the
	# cores available for processing, having a ridiculus number of processing blocks, 
	# and not having a lot of "NoData" space in the final rasters.
	# I chose to limit the NoData space. 

	#min and max values for the grid metrics
	cellMinX <- lidarExtent$xMinPoints - lidarExtent$xMinPoints %% cellSize
	cellMinY <- lidarExtent$yMinPoints - lidarExtent$yMinPoints %% cellSize
	
	cellMaxX <- lidarExtent$xMaxPoints - lidarExtent$xMaxPoints %% cellSize + cellSize
	cellMaxY <- lidarExtent$yMaxPoints - lidarExtent$yMaxPoints %% cellSize + cellSize
	
	
	blockRangeX <- cellMaxX - cellMinX + 2*cellSize #Add a little buffer on each side of the block
	blockRangeY <- cellMaxY - cellMinY + 2*cellSize #Add a little buffer on each side of the block
	
	#Just make it 3000 meters...
	blockWidth <- cellSize*100
	blockHeight <- cellSize*100
	
	
	#2017.01.27	Change tileWidth from 3000 to 21000
	tileWidth <- 21000
	tileHeight <- 21000
	
	#calculate how many blocks are needed in the X direction
	
	#long east to west unit
	if(((blockRangeX / blockRangeY) > 6) & (blockRangeY < 100*cellSize)){
		nBlocksHigh <- 1 
		nBlocksWide <- ifelse(ceiling(blockRangeX / blockWidth) > 2, ceiling(blockRangeX / blockWidth), 2)
	} else {
		#long north to south unit
		if(((blockRangeY / blockRangeX) > 6) & (blockRangeX < 100*cellSize)){
			nBlocksHigh <- ifelse(ceiling(blockRangeY / blockHeight) > 2, ceiling(blockRangeY / blockHeight), 2)
			nBlocksWide <- 1
		} else {
			#calculate how many blocks are needed in the X direction
			nBlocksWide <- ifelse(ceiling(blockRangeX / blockWidth) > 2, ceiling(blockRangeX / blockWidth), 2)
			#calculate how many blocks are needed in the Y direction
			nBlocksHigh <- ifelse(ceiling(blockRangeY / blockHeight) > 2, ceiling(blockRangeY / blockHeight), 2)
		}
	}
	
	#What about scenarios when less than nCores cores are being used? 
	if(nBlocksWide * nBlocksHigh < nCores){
		#reassign nCores
		nCores <- nBlocksWide * nBlocksHigh 
	}


	#Writes the PRP file
	writePRP(PROJECT = project, LATITUDE = latitude, 
		HOMEFOLDER = HOMEFOLDER, PROCESSINGHOME = PROCESSINGHOME,
		DIRSCRIPTS = DIRSCRIPTS,
		PRODUCTHOME = PRODUCTHOME, DIR_LIDAR = DIR_LIDAR,
		tileWidth = tileWidth, tileHeight = tileHeight, 
		blockWidth = blockWidth, blockHeight = blockHeight, 
		nBlocksHigh = nBlocksHigh, nBlocksWide = nBlocksWide,
		nCores = nCores, DTMSPEC = DTMSPEC,
		dirFUSION = dirFUSION, lidarExtent = lidarExtent)
}


# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# Create the PRP
# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------

createPRP(
  project = project, 
  cellSize = CELLSIZE, 
  nCores = NCORESMAX, 
  DIR_BASE = DIR_BASE, 
  DIRSCRIPTS = DIRSCRIPTS, 
  DIR_LIDAR = DIR_LAZ5070, 
  dirFUSION = dirFUSION
)

